~~Notes on dealing with ungrounded actions and attributes~~
We currently ground all attributes and actions, ex. if there is a parameterized action pickup(?x), we create a separate
grounded pickup action for each possible ?x.
We do this because it is easier to implement, but we would prefer to leave object references ungrounded unless they must be grounded.
Groundings would start based on the objects mentioned in the goal condition, and propagate from there.
Similarly, we currently ground forall and exists statements via And and Or respectively. We would rather deal with the
quantifiers in a more elegant way. Dealing with parameterized actions/attributes and quantifiers more intelligently
would probably save computation.
If all actions affecting a certain variable that must be changed have the same, idempotent effect, then we can assume that effect. Modify the algorithm to exploit this. (It may not be worth the computational cost)

~~Condition Handling~~
Ideally, we'd convert each condition to conjunctive normal form (not yet implemented). We can treat guarantees on each clause separately (currently implemented for top-level conjunction). Within a clause, if one of the terms is guaranteed, the whole term is guaranteed (not yet implemented).
~~~Converting to CNF~~~
Tactics take in a goal ( set of formulas) and outputs either sat, unsat, a sequence of subgoals (what does that mean?), or fails
	ctx-simplify (or regular simplify)
	tseitin-cnf (converts to cnf, but may introduce extra variables to avoid )